/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.ingres.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ingres.h"
#include <regex.h>
#include "/opt/Ingres/IngresII/ingres/sig/esql/ingstat.c"

/** Initializes the ingres module */
void
init_ingres(void)
{
    static oid      logWritersBusy_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 1, 1 };

    static oid      maxWriteQueueLength_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 1, 2 };

    static oid      maxWriteQueueCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 1, 3 };

    static oid      logWaits_oid[] = { 1, 3, 6, 1, 4, 1, 757, 4, 1, 1, 4 };

    static oid      splitBuffer_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 1, 60, 1 };

    static oid      freeBuffer_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 1, 60, 2 };

    static oid      lastBuf_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 1, 60, 3 };

    static oid      logFullStall_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 1, 60, 4 };

    static oid      lockWait_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 10, 1 };

    static oid      deadlock_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 10, 2 };

    static oid      highwaterLBK_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 10, 3 };

    static oid      highwaterSBK_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 10, 4 };

    static oid      highwaterRBK_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 10, 5 };

    static oid      totalLocks_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 11, 1 };

    static oid      totalResources_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 11, 2 };

    static oid      locksPerTransaction_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 11, 3 };

    static oid      locksInUse_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 11, 4 };

    static oid      resourcesInUse_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 11, 5 };

    static oid      lockListsInUse_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 11, 6 };

    static oid      totalLockLists_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 4, 1, 2, 11, 7 };

    static oid      serverID_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 2, 1, 1 };

    static oid      avgRows_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 2, 1, 2 };

    static oid      listenFails_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 2, 1, 3 };

    static oid      selectsProcessed_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 2, 1, 4 };

    static oid      currentConnections_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 2, 1, 5 };

    static oid      highwaterConnections_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 2, 1, 6 };

    static oid      listenMask_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 2, 1, 7 };

    static oid      listenState_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 2, 1, 8 };

    static oid      shutdownState_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 2, 1, 9 };

    static oid      serverState_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 2, 1, 10 };

    static oid      serverStateMask_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 2, 1, 11 };

    static oid      server_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 3, 1, 1 };

    static oid      startupName_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 3, 1, 2 };

    static oid      serverName_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 3, 1, 3 };

    static oid      startupTime_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 3, 1, 4 };

    static oid      serverPID_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 3, 1, 5 };

    static oid      fastCommit_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 3, 1, 6 };

    static oid      psfMemory_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 1, 3, 1, 7 };


    DEBUGMSGTL(("ingres", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("logWritersBusy", handle_logWritersBusy,
                             logWritersBusy_oid,
                             OID_LENGTH(logWritersBusy_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised logWritersBusy as .1.3.6.1.4.1.757.4.1.1.1\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("maxWriteQueueLength",
                             handle_maxWriteQueueLength,
                             maxWriteQueueLength_oid,
                             OID_LENGTH(maxWriteQueueLength_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised maxWriteQueueLength as .1.3.6.1.4.1.757.4.1.1.2\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("maxWriteQueueCount",
                             handle_maxWriteQueueCount,
                             maxWriteQueueCount_oid,
                             OID_LENGTH(maxWriteQueueCount_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised maxWriteQueueCount as .1.3.6.1.4.1.757.4.1.1.3\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("logWaits", handle_logWaits, logWaits_oid,
                             OID_LENGTH(logWaits_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised logWaits as .1.3.6.1.4.1.757.4.1.1.4\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("splitBuffer", handle_splitBuffer,
                             splitBuffer_oid, OID_LENGTH(splitBuffer_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised splitBuffer as .1.3.6.1.4.1.757.4.1.1.60.1\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("freeBuffer", handle_freeBuffer,
                             freeBuffer_oid, OID_LENGTH(freeBuffer_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised freeBuffer as .1.3.6.1.4.1.757.4.1.1.60.2\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("lastBuf", handle_lastBuf, lastBuf_oid,
                             OID_LENGTH(lastBuf_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised lastBuf as .1.3.6.1.4.1.757.4.1.1.60.3\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("logFullStall", handle_logFullStall,
                             logFullStall_oid,
                             OID_LENGTH(logFullStall_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised logFullStall as .1.3.6.1.4.1.757.4.1.1.60.4\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("lockWait", handle_lockWait, lockWait_oid,
                             OID_LENGTH(lockWait_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised lockWait as .1.3.6.1.4.1.757.4.1.2.10.1\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("deadlock", handle_deadlock, deadlock_oid,
                             OID_LENGTH(deadlock_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised deadlock as .1.3.6.1.4.1.757.4.1.2.10.2\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("highwaterLBK", handle_highwaterLBK,
                             highwaterLBK_oid,
                             OID_LENGTH(highwaterLBK_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised highwaterLBK as .1.3.6.1.4.1.757.4.1.2.10.3\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("highwaterSBK", handle_highwaterSBK,
                             highwaterSBK_oid,
                             OID_LENGTH(highwaterSBK_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised highwaterSBK as .1.3.6.1.4.1.757.4.1.2.10.4\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("highwaterRBK", handle_highwaterRBK,
                             highwaterRBK_oid,
                             OID_LENGTH(highwaterRBK_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised highwaterRBK as .1.3.6.1.4.1.757.4.1.2.10.5\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("totalLocks", handle_totalLocks,
                             totalLocks_oid, OID_LENGTH(totalLocks_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised totalLocks as .1.3.6.1.4.1.757.4.1.2.11.1\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("totalResources", handle_totalResources,
                             totalResources_oid,
                             OID_LENGTH(totalResources_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised totalResources as .1.3.6.1.4.1.757.4.1.2.11.2\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("locksPerTransaction",
                             handle_locksPerTransaction,
                             locksPerTransaction_oid,
                             OID_LENGTH(locksPerTransaction_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised locksPerTransaction as .1.3.6.1.4.1.757.4.1.2.11.3\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("locksInUse", handle_locksInUse,
                             locksInUse_oid, OID_LENGTH(locksInUse_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised locksInUse as .1.3.6.1.4.1.757.4.1.2.11.4\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("resourcesInUse", handle_resourcesInUse,
                             resourcesInUse_oid,
                             OID_LENGTH(resourcesInUse_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised resourcesInUse as .1.3.6.1.4.1.757.4.1.2.11.5\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("lockListsInUse", handle_lockListsInUse,
                             lockListsInUse_oid,
                             OID_LENGTH(lockListsInUse_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised lockListsInUse as .1.3.6.1.4.1.757.4.1.2.11.6\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("totalLockLists", handle_totalLockLists,
                             totalLockLists_oid,
                             OID_LENGTH(totalLockLists_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised totalLockLists as .1.3.6.1.4.1.757.4.1.2.11.7\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("serverID", handle_serverID, serverID_oid,
                             OID_LENGTH(serverID_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised serverID as .1.3.6.1.4.1.757.5.1.2.1.1\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("avgRows", handle_avgRows, avgRows_oid,
                             OID_LENGTH(avgRows_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised avgRows as .1.3.6.1.4.1.757.5.1.2.1.2\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("listenFails", handle_listenFails,
                             listenFails_oid, OID_LENGTH(listenFails_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised listenFails as .1.3.6.1.4.1.757.5.1.2.1.3\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("selectsProcessed", handle_selectsProcessed,
                             selectsProcessed_oid,
                             OID_LENGTH(selectsProcessed_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised selectsProcessed as .1.3.6.1.4.1.757.5.1.2.1.4\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("currentConnections",
                             handle_currentConnections,
                             currentConnections_oid,
                             OID_LENGTH(currentConnections_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised currentConnections as .1.3.6.1.4.1.757.5.1.2.1.5\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("highwaterConnections",
                             handle_highwaterConnections,
                             highwaterConnections_oid,
                             OID_LENGTH(highwaterConnections_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised highwaterConnections as .1.3.6.1.4.1.757.5.1.2.1.6\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("listenMask", handle_listenMask,
                             listenMask_oid, OID_LENGTH(listenMask_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised listenMask as .1.3.6.1.4.1.757.5.1.2.1.7\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("listenState", handle_listenState,
                             listenState_oid, OID_LENGTH(listenState_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised listenState as .1.3.6.1.4.1.757.5.1.2.1.8\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("shutdownState", handle_shutdownState,
                             shutdownState_oid,
                             OID_LENGTH(shutdownState_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised shutdownState as .1.3.6.1.4.1.757.5.1.2.1.9\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("serverState", handle_serverState,
                             serverState_oid, OID_LENGTH(serverState_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised serverState as .1.3.6.1.4.1.757.5.1.2.1.10\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("serverStateMask", handle_serverStateMask,
                             serverStateMask_oid,
                             OID_LENGTH(serverStateMask_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised serverStateMask as .1.3.6.1.4.1.757.5.1.2.1.11\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("server", handle_server, server_oid,
                             OID_LENGTH(server_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised server as .1.3.6.1.4.1.757.5.1.3.1.1\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("startupName", handle_startupName,
                             startupName_oid, OID_LENGTH(startupName_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised startupName as .1.3.6.1.4.1.757.5.1.3.1.2\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("serverName", handle_serverName,
                             serverName_oid, OID_LENGTH(serverName_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised serverName as .1.3.6.1.4.1.757.5.1.3.1.3\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("startupTime", handle_startupTime,
                             startupTime_oid, OID_LENGTH(startupTime_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised startupTime as .1.3.6.1.4.1.757.5.1.3.1.4\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("serverPID", handle_serverPID, serverPID_oid,
                             OID_LENGTH(serverPID_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised serverPID as .1.3.6.1.4.1.757.5.1.3.1.5\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("fastCommit", handle_fastCommit,
                             fastCommit_oid, OID_LENGTH(fastCommit_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised fastCommit as .1.3.6.1.4.1.757.5.1.3.1.6\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("psfMemory", handle_psfMemory, psfMemory_oid,
                             OID_LENGTH(psfMemory_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised psfMemory as .1.3.6.1.4.1.757.5.1.3.1.7\n"));

}

int
handle_logWritersBusy(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "logwriters busy\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "logwriters busy\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_logWritersBusy\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_maxWriteQueueLength(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "write queue len\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "write queue len\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_maxWriteQueueLength\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_maxWriteQueueCount(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "write queue cnt\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "write queue cnt\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_maxWriteQueueCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_logWaits(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Log waits\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Log waits\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_logWaits\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_splitBuffer(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logWaitsByType";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Split Buffer\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Split Buffer\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_splitBuffer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_freeBuffer(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logWaitsByType";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Free Buffer\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Free Buffer\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_freeBuffer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lastBuf(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logWaitsByType";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Lastbuf\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Lastbuf\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_lastBuf\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_logFullStall(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logWaitsByType";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Logfull Stall\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Logfull Stall\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_logFullStall\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lockWait(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockStatistics";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_lockWait\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_deadlock(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockStatistics";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_deadlock\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_highwaterLBK(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockStatistics";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_highwaterLBK\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_highwaterSBK(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockStatistics";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_highwaterSBK\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_highwaterRBK(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockStatistics";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_highwaterRBK\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_totalLocks(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Total Locks\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Total Locks\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_totalLocks\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_totalResources(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Total Resources\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Total Resources\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_totalResources\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_locksPerTransaction(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Locks per transaction\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Locks per transaction\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_locksPerTransaction\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_locksInUse(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Locks in use\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Locks in use\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_locksInUse\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_resourcesInUse(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Resources in use\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Resources in use\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_resourcesInUse\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lockListsInUse(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Lock lists in use\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Lock lists in use\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_lockListsInUse\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_totalLockLists(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Total lock lists\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Total lock lists\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_totalLockLists\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_serverID(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverStatusEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_serverID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_avgRows(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverStatusEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_INTEGER,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_avgRows\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_listenFails(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverStatusEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_INTEGER,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_listenFails\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_selectsProcessed(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverStatusEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_INTEGER,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_selectsProcessed\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_currentConnections(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverStatusEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_INTEGER,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_currentConnections\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_highwaterConnections(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverStatusEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_INTEGER,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_highwaterConnections\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_listenMask(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverStatusEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_INTEGER,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_listenMask\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_listenState(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverStatusEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_listenState\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_shutdownState(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverStatusEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_shutdownState\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_serverState(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverStatusEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_serverState\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_serverStateMask(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverStatusEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_INTEGER,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_serverStateMask\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_server(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverParametersEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_server\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_startupName(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverParametersEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_startupName\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_serverName(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverParametersEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_serverName\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_startupTime(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverParametersEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_startupTime\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_serverPID(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverParametersEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_INTEGER,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_serverPID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_fastCommit(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverParametersEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_INTEGER,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_fastCommit\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_psfMemory(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "serverParametersEntry";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_INTEGER,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_psfMemory\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
