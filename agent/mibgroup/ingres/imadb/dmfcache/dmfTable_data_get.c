/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12088 $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "dmfTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dmfTable get routines.
 * TODO:240:M: Implement dmfTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dmfTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * INGRES-MIB::dmfTable is subid 1 of imadb.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.757.5.1.1, length: 10
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement dmfTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param server_ptr
 * @param server_ptr_len
 * @param pagesize_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dmfTable_indexes_set_tbl_idx(dmfTable_mib_index * tbl_idx,
                             char *server_val_ptr,
                             size_t server_val_ptr_len, long pagesize_val)
{
    DEBUGMSGTL(("verbose:dmfTable:dmfTable_indexes_set_tbl_idx",
                "called\n"));

    /*
     * server(1)/DisplayString/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H 
     */
    tbl_idx->server_len = sizeof(tbl_idx->server) / sizeof(tbl_idx->server[0]); /* max length */
    /*
     * make sure there is enough space for server data
     */
    if ((NULL == tbl_idx->server) ||
        (tbl_idx->server_len < (server_val_ptr_len))) {
        snmp_log(LOG_ERR, "not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->server_len = server_val_ptr_len;
    memcpy(tbl_idx->server, server_val_ptr,
           server_val_ptr_len * sizeof(server_val_ptr[0]));

    /*
     * pagesize(2)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h 
     */
    tbl_idx->pagesize = pagesize_val;


    return MFD_SUCCESS;
}                               /* dmfTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dmfTable_indexes_set(dmfTable_rowreq_ctx * rowreq_ctx,
                     char *server_val_ptr, size_t server_val_ptr_len,
                     long pagesize_val)
{
    DEBUGMSGTL(("verbose:dmfTable:dmfTable_indexes_set", "called\n"));

    if (MFD_SUCCESS !=
        dmfTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, server_val_ptr,
                                     server_val_ptr_len, pagesize_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != dmfTable_index_to_oid(&rowreq_ctx->oid_idx,
                                   &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* dmfTable_indexes_set */


/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.forceCount
 * forceCount is subid 3 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.3
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the forceCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param forceCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
forceCount_get(dmfTable_rowreq_ctx * rowreq_ctx, long *forceCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != forceCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:forceCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the forceCount data.
     * copy (* forceCount_val_ptr ) from rowreq_ctx->data
     */
    (*forceCount_val_ptr) = rowreq_ctx->data.forceCount;

    return MFD_SUCCESS;
}                               /* forceCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.ioWaitCount
 * ioWaitCount is subid 4 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.4
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ioWaitCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ioWaitCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ioWaitCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                long *ioWaitCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ioWaitCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:ioWaitCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the ioWaitCount data.
     * copy (* ioWaitCount_val_ptr ) from rowreq_ctx->data
     */
    (*ioWaitCount_val_ptr) = rowreq_ctx->data.ioWaitCount;

    return MFD_SUCCESS;
}                               /* ioWaitCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.groupBufferReadCount
 * groupBufferReadCount is subid 5 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.5
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the groupBufferReadCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param groupBufferReadCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
groupBufferReadCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                         long *groupBufferReadCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != groupBufferReadCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:groupBufferReadCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the groupBufferReadCount data.
     * copy (* groupBufferReadCount_val_ptr ) from rowreq_ctx->data
     */
    (*groupBufferReadCount_val_ptr) =
        rowreq_ctx->data.groupBufferReadCount;

    return MFD_SUCCESS;
}                               /* groupBufferReadCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.groupBufferWriteCount
 * groupBufferWriteCount is subid 6 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.6
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the groupBufferWriteCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param groupBufferWriteCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
groupBufferWriteCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                          long *groupBufferWriteCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != groupBufferWriteCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:groupBufferWriteCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the groupBufferWriteCount data.
     * copy (* groupBufferWriteCount_val_ptr ) from rowreq_ctx->data
     */
    (*groupBufferWriteCount_val_ptr) =
        rowreq_ctx->data.groupBufferWriteCount;

    return MFD_SUCCESS;
}                               /* groupBufferWriteCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.fixCount
 * fixCount is subid 7 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.7
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the fixCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param fixCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
fixCount_get(dmfTable_rowreq_ctx * rowreq_ctx, long *fixCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != fixCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:fixCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the fixCount data.
     * copy (* fixCount_val_ptr ) from rowreq_ctx->data
     */
    (*fixCount_val_ptr) = rowreq_ctx->data.fixCount;

    return MFD_SUCCESS;
}                               /* fixCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.unfixCount
 * unfixCount is subid 8 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.8
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the unfixCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param unfixCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
unfixCount_get(dmfTable_rowreq_ctx * rowreq_ctx, long *unfixCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != unfixCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:unfixCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the unfixCount data.
     * copy (* unfixCount_val_ptr ) from rowreq_ctx->data
     */
    (*unfixCount_val_ptr) = rowreq_ctx->data.unfixCount;

    return MFD_SUCCESS;
}                               /* unfixCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.readCount
 * readCount is subid 9 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.9
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the readCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param readCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
readCount_get(dmfTable_rowreq_ctx * rowreq_ctx, long *readCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != readCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:readCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the readCount data.
     * copy (* readCount_val_ptr ) from rowreq_ctx->data
     */
    (*readCount_val_ptr) = rowreq_ctx->data.readCount;

    return MFD_SUCCESS;
}                               /* readCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.writeCount
 * writeCount is subid 10 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.10
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the writeCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param writeCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
writeCount_get(dmfTable_rowreq_ctx * rowreq_ctx, long *writeCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != writeCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:writeCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the writeCount data.
     * copy (* writeCount_val_ptr ) from rowreq_ctx->data
     */
    (*writeCount_val_ptr) = rowreq_ctx->data.writeCount;

    return MFD_SUCCESS;
}                               /* writeCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.hitCount
 * hitCount is subid 11 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.11
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the hitCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param hitCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
hitCount_get(dmfTable_rowreq_ctx * rowreq_ctx, long *hitCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != hitCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:hitCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the hitCount data.
     * copy (* hitCount_val_ptr ) from rowreq_ctx->data
     */
    (*hitCount_val_ptr) = rowreq_ctx->data.hitCount;

    return MFD_SUCCESS;
}                               /* hitCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.dirtyUnfixCount
 * dirtyUnfixCount is subid 12 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.12
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the dirtyUnfixCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param dirtyUnfixCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
dirtyUnfixCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                    long *dirtyUnfixCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != dirtyUnfixCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:dirtyUnfixCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the dirtyUnfixCount data.
     * copy (* dirtyUnfixCount_val_ptr ) from rowreq_ctx->data
     */
    (*dirtyUnfixCount_val_ptr) = rowreq_ctx->data.dirtyUnfixCount;

    return MFD_SUCCESS;
}                               /* dirtyUnfixCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.pagesStillValid
 * pagesStillValid is subid 13 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.13
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the pagesStillValid data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pagesStillValid_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pagesStillValid_get(dmfTable_rowreq_ctx * rowreq_ctx,
                    long *pagesStillValid_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pagesStillValid_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:pagesStillValid_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pagesStillValid data.
     * copy (* pagesStillValid_val_ptr ) from rowreq_ctx->data
     */
    (*pagesStillValid_val_ptr) = rowreq_ctx->data.pagesStillValid;

    return MFD_SUCCESS;
}                               /* pagesStillValid_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.pagesInvalid
 * pagesInvalid is subid 14 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.14
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the pagesInvalid data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pagesInvalid_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pagesInvalid_get(dmfTable_rowreq_ctx * rowreq_ctx,
                 long *pagesInvalid_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pagesInvalid_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:pagesInvalid_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pagesInvalid data.
     * copy (* pagesInvalid_val_ptr ) from rowreq_ctx->data
     */
    (*pagesInvalid_val_ptr) = rowreq_ctx->data.pagesInvalid;

    return MFD_SUCCESS;
}                               /* pagesInvalid_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.bufferCount
 * bufferCount is subid 15 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.15
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the bufferCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param bufferCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
bufferCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                long *bufferCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != bufferCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:bufferCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the bufferCount data.
     * copy (* bufferCount_val_ptr ) from rowreq_ctx->data
     */
    (*bufferCount_val_ptr) = rowreq_ctx->data.bufferCount;

    return MFD_SUCCESS;
}                               /* bufferCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.pageBufferCount
 * pageBufferCount is subid 16 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.16
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the pageBufferCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pageBufferCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pageBufferCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                    long *pageBufferCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pageBufferCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:pageBufferCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pageBufferCount data.
     * copy (* pageBufferCount_val_ptr ) from rowreq_ctx->data
     */
    (*pageBufferCount_val_ptr) = rowreq_ctx->data.pageBufferCount;

    return MFD_SUCCESS;
}                               /* pageBufferCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.fLimit
 * fLimit is subid 17 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.17
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the fLimit data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param fLimit_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
fLimit_get(dmfTable_rowreq_ctx * rowreq_ctx, long *fLimit_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != fLimit_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:fLimit_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the fLimit data.
     * copy (* fLimit_val_ptr ) from rowreq_ctx->data
     */
    (*fLimit_val_ptr) = rowreq_ctx->data.fLimit;

    return MFD_SUCCESS;
}                               /* fLimit_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.mLimit
 * mLimit is subid 18 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.18
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the mLimit data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param mLimit_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
mLimit_get(dmfTable_rowreq_ctx * rowreq_ctx, long *mLimit_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != mLimit_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:mLimit_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the mLimit data.
     * copy (* mLimit_val_ptr ) from rowreq_ctx->data
     */
    (*mLimit_val_ptr) = rowreq_ctx->data.mLimit;

    return MFD_SUCCESS;
}                               /* mLimit_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.wbStart
 * wbStart is subid 19 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.19
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wbStart data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wbStart_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wbStart_get(dmfTable_rowreq_ctx * rowreq_ctx, long *wbStart_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wbStart_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:wbStart_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wbStart data.
     * copy (* wbStart_val_ptr ) from rowreq_ctx->data
     */
    (*wbStart_val_ptr) = rowreq_ctx->data.wbStart;

    return MFD_SUCCESS;
}                               /* wbStart_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.wbEnd
 * wbEnd is subid 20 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.20
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the wbEnd data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wbEnd_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wbEnd_get(dmfTable_rowreq_ctx * rowreq_ctx, long *wbEnd_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != wbEnd_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:wbEnd_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the wbEnd data.
     * copy (* wbEnd_val_ptr ) from rowreq_ctx->data
     */
    (*wbEnd_val_ptr) = rowreq_ctx->data.wbEnd;

    return MFD_SUCCESS;
}                               /* wbEnd_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.hashBucketCount
 * hashBucketCount is subid 21 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.21
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the hashBucketCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param hashBucketCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
hashBucketCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                    long *hashBucketCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != hashBucketCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:hashBucketCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the hashBucketCount data.
     * copy (* hashBucketCount_val_ptr ) from rowreq_ctx->data
     */
    (*hashBucketCount_val_ptr) = rowreq_ctx->data.hashBucketCount;

    return MFD_SUCCESS;
}                               /* hashBucketCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.groupBufferCount
 * groupBufferCount is subid 22 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.22
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the groupBufferCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param groupBufferCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
groupBufferCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                     long *groupBufferCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != groupBufferCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:groupBufferCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the groupBufferCount data.
     * copy (* groupBufferCount_val_ptr ) from rowreq_ctx->data
     */
    (*groupBufferCount_val_ptr) = rowreq_ctx->data.groupBufferCount;

    return MFD_SUCCESS;
}                               /* groupBufferCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.groupBufferSize
 * groupBufferSize is subid 23 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.23
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the groupBufferSize data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param groupBufferSize_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
groupBufferSize_get(dmfTable_rowreq_ctx * rowreq_ctx,
                    long *groupBufferSize_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != groupBufferSize_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:groupBufferSize_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the groupBufferSize data.
     * copy (* groupBufferSize_val_ptr ) from rowreq_ctx->data
     */
    (*groupBufferSize_val_ptr) = rowreq_ctx->data.groupBufferSize;

    return MFD_SUCCESS;
}                               /* groupBufferSize_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.cacheStatus
 * cacheStatus is subid 24 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.24
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the cacheStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param cacheStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
cacheStatus_get(dmfTable_rowreq_ctx * rowreq_ctx,
                long *cacheStatus_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != cacheStatus_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:cacheStatus_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the cacheStatus data.
     * copy (* cacheStatus_val_ptr ) from rowreq_ctx->data
     */
    (*cacheStatus_val_ptr) = rowreq_ctx->data.cacheStatus;

    return MFD_SUCCESS;
}                               /* cacheStatus_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.freeBufferCount
 * freeBufferCount is subid 25 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.25
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the freeBufferCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param freeBufferCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
freeBufferCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                    long *freeBufferCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != freeBufferCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:freeBufferCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the freeBufferCount data.
     * copy (* freeBufferCount_val_ptr ) from rowreq_ctx->data
     */
    (*freeBufferCount_val_ptr) = rowreq_ctx->data.freeBufferCount;

    return MFD_SUCCESS;
}                               /* freeBufferCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.freeBufferWaiters
 * freeBufferWaiters is subid 26 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.26
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the freeBufferWaiters data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param freeBufferWaiters_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
freeBufferWaiters_get(dmfTable_rowreq_ctx * rowreq_ctx,
                      long *freeBufferWaiters_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != freeBufferWaiters_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:freeBufferWaiters_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the freeBufferWaiters data.
     * copy (* freeBufferWaiters_val_ptr ) from rowreq_ctx->data
     */
    (*freeBufferWaiters_val_ptr) = rowreq_ctx->data.freeBufferWaiters;

    return MFD_SUCCESS;
}                               /* freeBufferWaiters_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.fixedBufferCount
 * fixedBufferCount is subid 27 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.27
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the fixedBufferCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param fixedBufferCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
fixedBufferCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                     long *fixedBufferCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != fixedBufferCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:fixedBufferCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the fixedBufferCount data.
     * copy (* fixedBufferCount_val_ptr ) from rowreq_ctx->data
     */
    (*fixedBufferCount_val_ptr) = rowreq_ctx->data.fixedBufferCount;

    return MFD_SUCCESS;
}                               /* fixedBufferCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.modifiedBufferCount
 * modifiedBufferCount is subid 28 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.28
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the modifiedBufferCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param modifiedBufferCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
modifiedBufferCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                        long *modifiedBufferCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != modifiedBufferCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:modifiedBufferCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the modifiedBufferCount data.
     * copy (* modifiedBufferCount_val_ptr ) from rowreq_ctx->data
     */
    (*modifiedBufferCount_val_ptr) = rowreq_ctx->data.modifiedBufferCount;

    return MFD_SUCCESS;
}                               /* modifiedBufferCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.freeGroupBufferCount
 * freeGroupBufferCount is subid 29 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.29
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the freeGroupBufferCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param freeGroupBufferCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
freeGroupBufferCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                         long *freeGroupBufferCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != freeGroupBufferCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:freeGroupBufferCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the freeGroupBufferCount data.
     * copy (* freeGroupBufferCount_val_ptr ) from rowreq_ctx->data
     */
    (*freeGroupBufferCount_val_ptr) =
        rowreq_ctx->data.freeGroupBufferCount;

    return MFD_SUCCESS;
}                               /* freeGroupBufferCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.fixedGroupBufferCount
 * fixedGroupBufferCount is subid 30 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.30
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the fixedGroupBufferCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param fixedGroupBufferCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
fixedGroupBufferCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                          long *fixedGroupBufferCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != fixedGroupBufferCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:fixedGroupBufferCount_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the fixedGroupBufferCount data.
     * copy (* fixedGroupBufferCount_val_ptr ) from rowreq_ctx->data
     */
    (*fixedGroupBufferCount_val_ptr) =
        rowreq_ctx->data.fixedGroupBufferCount;

    return MFD_SUCCESS;
}                               /* fixedGroupBufferCount_get */

/*---------------------------------------------------------------------
 * INGRES-MIB::dmfEntry.modifiedGroupBufferCount
 * modifiedGroupBufferCount is subid 31 of dmfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.757.5.1.1.1.31
 * Description:
Please replace this text with your description.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the modifiedGroupBufferCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param modifiedGroupBufferCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
modifiedGroupBufferCount_get(dmfTable_rowreq_ctx * rowreq_ctx,
                             long *modifiedGroupBufferCount_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != modifiedGroupBufferCount_val_ptr);


    DEBUGMSGTL(("verbose:dmfTable:modifiedGroupBufferCount_get",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the modifiedGroupBufferCount data.
     * copy (* modifiedGroupBufferCount_val_ptr ) from rowreq_ctx->data
     */
    (*modifiedGroupBufferCount_val_ptr) =
        rowreq_ctx->data.modifiedGroupBufferCount;

    return MFD_SUCCESS;
}                               /* modifiedGroupBufferCount_get */



/** @} */
