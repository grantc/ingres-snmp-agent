/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.ingres.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "lockstat.h"
#include <regex.h>
#include "/opt/Ingres/IngresII/ingres/sig/esql/ingstat.c"

/** Initializes the lockstat module */
void
init_lockstat(void)
{
    static oid      lockWait_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 10, 1 };

    static oid      deadlock_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 10, 2 };

    static oid      highwaterLBK_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 10, 3 };

    static oid      highwaterSBK_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 10, 4 };

    static oid      highwaterRBK_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 10, 5 };

    static oid      totalLocks_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 11, 1 };

    static oid      totalResources_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 11, 2 };

    static oid      locksPerTransaction_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 11, 3 };

    static oid      locksInUse_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 11, 4 };

    static oid      resourcesInUse_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 11, 5 };

    static oid      lockListsInUse_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 11, 6 };

    static oid      totalLockLists_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 4, 11, 7 };


    DEBUGMSGTL(("lockstat", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("lockWait", handle_lockWait, lockWait_oid,
                             OID_LENGTH(lockWait_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised lockWait as .1.3.6.1.4.1.757.5.4.10.1\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("deadlock", handle_deadlock, deadlock_oid,
                             OID_LENGTH(deadlock_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised deadlock as .1.3.6.1.4.1.757.5.4.10.2\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("highwaterLBK", handle_highwaterLBK,
                             highwaterLBK_oid,
                             OID_LENGTH(highwaterLBK_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised highwaterLBK as .1.3.6.1.4.1.757.5.4.10.3\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("highwaterSBK", handle_highwaterSBK,
                             highwaterSBK_oid,
                             OID_LENGTH(highwaterSBK_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised highwaterSBK as .1.3.6.1.4.1.757.5.4.10.4\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("highwaterRBK", handle_highwaterRBK,
                             highwaterRBK_oid,
                             OID_LENGTH(highwaterRBK_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised highwaterRBK as .1.3.6.1.4.1.757.5.4.10.5\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("totalLocks", handle_totalLocks,
                             totalLocks_oid, OID_LENGTH(totalLocks_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised totalLocks as .1.3.6.1.4.1.757.5.4.11.1\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("totalResources", handle_totalResources,
                             totalResources_oid,
                             OID_LENGTH(totalResources_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised totalResources as .1.3.6.1.4.1.757.5.4.11.2\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("locksPerTransaction",
                             handle_locksPerTransaction,
                             locksPerTransaction_oid,
                             OID_LENGTH(locksPerTransaction_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised locksPerTransaction as .1.3.6.1.4.1.757.5.4.11.3\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("locksInUse", handle_locksInUse,
                             locksInUse_oid, OID_LENGTH(locksInUse_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised locksInUse as .1.3.6.1.4.1.757.5.4.11.4\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("resourcesInUse", handle_resourcesInUse,
                             resourcesInUse_oid,
                             OID_LENGTH(resourcesInUse_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised resourcesInUse as .1.3.6.1.4.1.757.5.4.11.5\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("lockListsInUse", handle_lockListsInUse,
                             lockListsInUse_oid,
                             OID_LENGTH(lockListsInUse_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised lockListsInUse as .1.3.6.1.4.1.757.5.4.11.6\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("totalLockLists", handle_totalLockLists,
                             totalLockLists_oid,
                             OID_LENGTH(totalLockLists_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised totalLockLists as .1.3.6.1.4.1.757.5.4.11.7\n"));

}

int
handle_lockWait(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockStatistics";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_lockWait\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_deadlock(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockStatistics";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_deadlock\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_highwaterLBK(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockStatistics";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_highwaterLBK\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_highwaterSBK(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockStatistics";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_highwaterSBK\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_highwaterRBK(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockStatistics";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_highwaterRBK\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_totalLocks(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Total Locks\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Total Locks\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_totalLocks\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_totalResources(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Total Resources\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Total Resources\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_totalResources\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_locksPerTransaction(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Locks per transaction\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Locks per transaction\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_locksPerTransaction\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_locksInUse(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Locks in use\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Locks in use\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_locksInUse\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_resourcesInUse(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Resources in use\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Resources in use\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_resourcesInUse\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lockListsInUse(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Lock lists in use\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Lock lists in use\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_lockListsInUse\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_totalLockLists(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockSummary";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if ((parent == "logstat") || (parent == "logWaitsByType")) {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Total lock lists\\s+([0-9]+)");
        }

        else if ((parent == "lockStatistics") || (parent == "lockSummary")) {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Total lock lists\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_totalLockLists\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
