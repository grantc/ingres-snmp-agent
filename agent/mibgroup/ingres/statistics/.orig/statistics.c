/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.ingres.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "statistics.h"
#include <regex.h>
#include "ingstat.h"

/** Initializes the statistics module */
void
init_statistics(void)
{
    static oid      logWritersBusy_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 1, 1 };

    static oid      maxWriteQueueLength_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 1, 2 };

    static oid      maxWriteQueueCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 1, 3 };

    static oid      logWaits_oid[] = { 1, 3, 6, 1, 4, 1, 757, 5, 2, 1, 4 };

    static oid      splitBuffer_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 1, 5 };

    static oid      freeBuffer_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 1, 6 };

    static oid      lastBuf_oid[] = { 1, 3, 6, 1, 4, 1, 757, 5, 2, 1, 7 };

    static oid      logFullStall_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 1, 8 };

    static oid      totalLocks_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 1 };

    static oid      totalResources_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 2 };

    static oid      locksPerTransaction_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 3 };

    static oid      locksInUse_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 4 };

    static oid      resourcesInUse_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 5 };

    static oid      lockListsInUse_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 6 };

    static oid      totalLockLists_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 7 };

    static oid      lockWait_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 10 };

    static oid      deadlock_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 11 };

    static oid      highwaterLBK_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 12 };

    static oid      highwaterSBK_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 13 };

    static oid      highwaterRBK_oid[] =
        { 1, 3, 6, 1, 4, 1, 757, 5, 2, 2, 14 };


    DEBUGMSGTL(("statistics", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("logWritersBusy", handle_logWritersBusy,
                             logWritersBusy_oid,
                             OID_LENGTH(logWritersBusy_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised logWritersBusy as .1.3.6.1.4.1.757.5.2.1.1\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("maxWriteQueueLength",
                             handle_maxWriteQueueLength,
                             maxWriteQueueLength_oid,
                             OID_LENGTH(maxWriteQueueLength_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised maxWriteQueueLength as .1.3.6.1.4.1.757.5.2.1.2\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("maxWriteQueueCount",
                             handle_maxWriteQueueCount,
                             maxWriteQueueCount_oid,
                             OID_LENGTH(maxWriteQueueCount_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised maxWriteQueueCount as .1.3.6.1.4.1.757.5.2.1.3\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("logWaits", handle_logWaits, logWaits_oid,
                             OID_LENGTH(logWaits_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised logWaits as .1.3.6.1.4.1.757.5.2.1.4\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("splitBuffer", handle_splitBuffer,
                             splitBuffer_oid, OID_LENGTH(splitBuffer_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised splitBuffer as .1.3.6.1.4.1.757.5.2.1.5\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("freeBuffer", handle_freeBuffer,
                             freeBuffer_oid, OID_LENGTH(freeBuffer_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised freeBuffer as .1.3.6.1.4.1.757.5.2.1.6\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("lastBuf", handle_lastBuf, lastBuf_oid,
                             OID_LENGTH(lastBuf_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised lastBuf as .1.3.6.1.4.1.757.5.2.1.7\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("logFullStall", handle_logFullStall,
                             logFullStall_oid,
                             OID_LENGTH(logFullStall_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised logFullStall as .1.3.6.1.4.1.757.5.2.1.8\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("totalLocks", handle_totalLocks,
                             totalLocks_oid, OID_LENGTH(totalLocks_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised totalLocks as .1.3.6.1.4.1.757.5.2.2.1\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("totalResources", handle_totalResources,
                             totalResources_oid,
                             OID_LENGTH(totalResources_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised totalResources as .1.3.6.1.4.1.757.5.2.2.2\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("locksPerTransaction",
                             handle_locksPerTransaction,
                             locksPerTransaction_oid,
                             OID_LENGTH(locksPerTransaction_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised locksPerTransaction as .1.3.6.1.4.1.757.5.2.2.3\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("locksInUse", handle_locksInUse,
                             locksInUse_oid, OID_LENGTH(locksInUse_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised locksInUse as .1.3.6.1.4.1.757.5.2.2.4\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("resourcesInUse", handle_resourcesInUse,
                             resourcesInUse_oid,
                             OID_LENGTH(resourcesInUse_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised resourcesInUse as .1.3.6.1.4.1.757.5.2.2.5\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("lockListsInUse", handle_lockListsInUse,
                             lockListsInUse_oid,
                             OID_LENGTH(lockListsInUse_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised lockListsInUse as .1.3.6.1.4.1.757.5.2.2.6\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("totalLockLists", handle_totalLockLists,
                             totalLockLists_oid,
                             OID_LENGTH(totalLockLists_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised totalLockLists as .1.3.6.1.4.1.757.5.2.2.7\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("lockWait", handle_lockWait, lockWait_oid,
                             OID_LENGTH(lockWait_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised lockWait as .1.3.6.1.4.1.757.5.2.2.10\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("deadlock", handle_deadlock, deadlock_oid,
                             OID_LENGTH(deadlock_oid), HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised deadlock as .1.3.6.1.4.1.757.5.2.2.11\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("highwaterLBK", handle_highwaterLBK,
                             highwaterLBK_oid,
                             OID_LENGTH(highwaterLBK_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised highwaterLBK as .1.3.6.1.4.1.757.5.2.2.12\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("highwaterSBK", handle_highwaterSBK,
                             highwaterSBK_oid,
                             OID_LENGTH(highwaterSBK_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised highwaterSBK as .1.3.6.1.4.1.757.5.2.2.13\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("highwaterRBK", handle_highwaterRBK,
                             highwaterRBK_oid,
                             OID_LENGTH(highwaterRBK_oid),
                             HANDLER_CAN_RONLY));
    DEBUGMSGTL(("ingres",
                "Initialised highwaterRBK as .1.3.6.1.4.1.757.5.2.2.14\n"));

}

int
handle_logWritersBusy(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "logwriters busy\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "logwriters busy\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_logWritersBusy\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_maxWriteQueueLength(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "write queue len\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "write queue len\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_maxWriteQueueLength\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_maxWriteQueueCount(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "write queue cnt\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "write queue cnt\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_maxWriteQueueCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_logWaits(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Log waits\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Log waits\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_logWaits\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_splitBuffer(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Split Buffer\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Split Buffer\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_splitBuffer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_freeBuffer(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Free Buffer\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Free Buffer\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_freeBuffer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lastBuf(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Lastbuf\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Lastbuf\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_lastBuf\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_logFullStall(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "logstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Logfull Stall\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Logfull Stall\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_logFullStall\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_totalLocks(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Total Locks\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Total Locks\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_totalLocks\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_totalResources(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Total Resources\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Total Resources\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_totalResources\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_locksPerTransaction(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Locks per transaction\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Locks per transaction\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_locksPerTransaction\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_locksInUse(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Locks in use\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Locks in use\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_locksInUse\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_resourcesInUse(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Resources in use\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Resources in use\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_resourcesInUse\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lockListsInUse(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Lock lists in use\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Lock lists in use\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_lockListsInUse\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_totalLockLists(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "Total lock lists\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "Total lock lists\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_totalLockLists\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lockWait(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_lockWait\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_deadlock(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_deadlock\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_highwaterLBK(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_highwaterLBK\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_highwaterSBK(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_highwaterSBK\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_highwaterRBK(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    char            OIDvalue[64] = "";
    char            ingcmd[64] = "";
    char            ingsearch[64] = "";
    char           *parent = "lockstat";

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        DEBUGMSGTL(("ingres", "Handler called for MODE_GET\n"));

        if (parent == "logstat") {
            strcpy(ingcmd, "logstat -statistics");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }

        else if (parent == "lockstat") {
            strcpy(ingcmd, "lockstat -summary");
            strcpy(ingsearch, "\\s+([0-9]+)");
        }
        ingstat(ingcmd, ingsearch, OIDvalue);
        DEBUGMSGTL(("ingres", "MODE_GET: iistat returned %s\n", OIDvalue));

        snmp_set_var_typed_value(requests->requestvb,
                                 ASN_OCTET_STR,
                                 (u_char *) OIDvalue, strlen(OIDvalue)
            );
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_highwaterRBK\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
