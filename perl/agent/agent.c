/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of agent.xs. Do not edit this file, edit agent.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "agent.xs"
/* -*- C -*- */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include <netdb.h>
#include <sys/socket.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#ifndef sv_undef
#define sv_undef PL_sv_undef
#endif

typedef struct handler_cb_data_s {
   SV *perl_cb;
} handler_cb_data;

typedef struct netsnmp_oid_s {
    oid                 *name;
    size_t               len;
    oid                  namebuf[ MAX_OID_LEN ];
} netsnmp_oid;

static int have_done_agent = 0;
static int have_done_lib = 0;

static int
not_here(char *s)
{
    croak("%s not implemented on this architecture", s);
    return -1;
}

static double
constant_MODE_G(char *name, int len, int arg)
{
    if (6 + 2 > len ) {
	errno = EINVAL;
	return 0;
    }
    switch (name[6 + 2]) {
    case '\0':
	if (strEQ(name + 6, "ET")) {	/* MODE_G removed */
#ifdef MODE_GET
	    return MODE_GET;
#else
	    goto not_there;
#endif
	}
    case 'B':
	if (strEQ(name + 6, "ETBULK")) {	/* MODE_G removed */
#ifdef MODE_GETBULK
	    return MODE_GETBULK;
#else
	    goto not_there;
#endif
	}
    case 'N':
	if (strEQ(name + 6, "ETNEXT")) {	/* MODE_G removed */
#ifdef MODE_GETNEXT
	    return MODE_GETNEXT;
#else
	    goto not_there;
#endif
	}
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

static double
constant_MODE_SET_R(char *name, int len, int arg)
{
    if (10 + 6 >= len ) {
	errno = EINVAL;
	return 0;
    }
    switch (name[10 + 6]) {
    case '1':
	if (strEQ(name + 10, "ESERVE1")) {	/* MODE_SET_R removed */
#ifdef MODE_SET_RESERVE1
	    return MODE_SET_RESERVE1;
#else
	    goto not_there;
#endif
	}
    case '2':
	if (strEQ(name + 10, "ESERVE2")) {	/* MODE_SET_R removed */
#ifdef MODE_SET_RESERVE2
	    return MODE_SET_RESERVE2;
#else
	    goto not_there;
#endif
	}
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

static double
constant_SNMP_ERR(char *name, int len, int arg)
{
    if (9 + 1 >= len ) {
	errno = EINVAL;
	return 0;
    }
    switch (name[9]) {

    case 'A':
	if (strEQ(name + 10, "UTHORIZATIONERROR")) {	/* SNMP_ERR_A removed */
#ifdef SNMP_ERR_AUTHORIZATIONERROR
	    return SNMP_ERR_AUTHORIZATIONERROR;
#else
	    goto not_there;
#endif
	}
        break;

    case 'B':
	if (strEQ(name + 10, "ADVALUE")) {	/* SNMP_ERR_B removed */
#ifdef SNMP_ERR_BADVALUE
	    return SNMP_ERR_BADVALUE;
#else
	    goto not_there;
#endif
	}
        break;

    case 'C':
	if (strEQ(name + 10, "OMMITFAILED")) {	/* SNMP_ERR_C removed */
#ifdef SNMP_ERR_COMMITFAILED
	    return SNMP_ERR_COMMITFAILED;
#else
	    goto not_there;
#endif
	}
        break;

    case 'G':
	if (strEQ(name + 10, "ENERR")) {	/* SNMP_ERR_G removed */
#ifdef SNMP_ERR_GENERR
	    return SNMP_ERR_GENERR;
#else
	    goto not_there;
#endif
	}
        break;

    case 'I':
	if (strEQ(name + 10, "NCONSISTENTVALUE")) {	/* SNMP_ERR_I removed */
#ifdef SNMP_ERR_INCONSISTENTVALUE
	    return SNMP_ERR_INCONSISTENTVALUE;
#else
	    goto not_there;
#endif
	}
        break;

    case 'N':
	if (strEQ(name + 10, "OACCESS")) {	/* SNMP_ERR_N removed */
#ifdef SNMP_ERR_NOACCESS
	    return SNMP_ERR_NOACCESS;
#else
	    goto not_there;
#endif
	}

	if (strEQ(name + 10, "OCREATION")) {	/* SNMP_ERR_N removed */
#ifdef SNMP_ERR_NOCREATION
	    return SNMP_ERR_NOCREATION;
#else
	    goto not_there;
#endif
	}

	if (strEQ(name + 10, "OERROR")) {	/* SNMP_ERR_N removed */
#ifdef SNMP_ERR_NOERROR
	    return SNMP_ERR_NOERROR;
#else
	    goto not_there;
#endif
	}

	if (strEQ(name + 10, "OSUCHNAME")) {	/* SNMP_ERR_N removed */
#ifdef SNMP_ERR_NOSUCHNAME
	    return SNMP_ERR_NOSUCHNAME;
#else
	    goto not_there;
#endif
	}

	if (strEQ(name + 10, "OTWRITABLE")) {	/* SNMP_ERR_N removed */
#ifdef SNMP_ERR_NOTWRITABLE
	    return SNMP_ERR_NOTWRITABLE;
#else
	    goto not_there;
#endif
	}
        break;

    case 'R':
	if (strEQ(name + 10, "EADONLY")) {	/* SNMP_ERR_R removed */
#ifdef SNMP_ERR_READONLY
	    return SNMP_ERR_READONLY;
#else
	    goto not_there;
#endif
	}

	if (strEQ(name + 10, "ESOURCEUNAVAILABLE")) {	/* SNMP_ERR_R removed */
#ifdef SNMP_ERR_RESOURCEUNAVAILABLE
	    return SNMP_ERR_RESOURCEUNAVAILABLE;
#else
	    goto not_there;
#endif
	}
        break;

    case 'T':
	if (strEQ(name + 10, "OOBIG")) {	/* SNMP_ERR_T removed */
#ifdef SNMP_ERR_TOOBIG
	    return SNMP_ERR_TOOBIG;
#else
	    goto not_there;
#endif
	}
        break;

    case 'U':
	if (strEQ(name + 10, "NDOFAILED")) {	/* SNMP_ERR_U removed */
#ifdef SNMP_ERR_UNDOFAILED
	    return SNMP_ERR_UNDOFAILED;
#else
	    goto not_there;
#endif
	}
        break;

    case 'W':
	if (strEQ(name + 10, "RONGENCODING")) {	/* SNMP_ERR_W removed */
#ifdef SNMP_ERR_WRONGENCODING
	    return SNMP_ERR_WRONGENCODING;
#else
	    goto not_there;
#endif
	}

	if (strEQ(name + 10, "RONGLENGTH")) {	/* SNMP_ERR_W removed */
#ifdef SNMP_ERR_WRONGLENGTH
	    return SNMP_ERR_WRONGLENGTH;
#else
	    goto not_there;
#endif
	}

	if (strEQ(name + 10, "RONGTYPE")) {	/* SNMP_ERR_W removed */
#ifdef SNMP_ERR_WRONGTYPE
	    return SNMP_ERR_WRONGTYPE;
#else
	    goto not_there;
#endif
	}

	if (strEQ(name + 10, "RONGVALUE")) {	/* SNMP_ERR_W removed */
#ifdef SNMP_ERR_WRONGVALUE
	    return SNMP_ERR_WRONGVALUE;
#else
	    goto not_there;
#endif
	}
    }
not_there:
    errno = ENOENT;
    return 0;
}
    
static double
constant_MODE_S(char *name, int len, int arg)
{
    if (6 + 3 >= len ) {
	errno = EINVAL;
	return 0;
    }
    switch (name[6 + 3]) {
    case 'A':
	if (strEQ(name + 6, "ET_ACTION")) {	/* MODE_S removed */
#ifdef MODE_SET_ACTION
	    return MODE_SET_ACTION;
#else
	    goto not_there;
#endif
	}
    case 'B':
	if (strEQ(name + 6, "ET_BEGIN")) {	/* MODE_S removed */
#ifdef MODE_SET_BEGIN
	    return MODE_SET_BEGIN;
#else
	    goto not_there;
#endif
	}
    case 'C':
	if (strEQ(name + 6, "ET_COMMIT")) {	/* MODE_S removed */
#ifdef MODE_SET_COMMIT
	    return MODE_SET_COMMIT;
#else
	    goto not_there;
#endif
	}
    case 'F':
	if (strEQ(name + 6, "ET_FREE")) {	/* MODE_S removed */
#ifdef MODE_SET_FREE
	    return MODE_SET_FREE;
#else
	    goto not_there;
#endif
	}
    case 'R':
	if (!strnEQ(name + 6,"ET_", 3))
	    break;
	return constant_MODE_SET_R(name, len, arg);
    case 'U':
	if (strEQ(name + 6, "ET_UNDO")) {	/* MODE_S removed */
#ifdef MODE_SET_UNDO
	    return MODE_SET_UNDO;
#else
	    goto not_there;
#endif
	}
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

static double
constant(char *name, int len, int arg)
{
    errno = 0;
    if (0 + 5 >= len ) {
	errno = EINVAL;
	return 0;
    }
    switch (name[0 + 5]) {
    case 'G':
	if (!strnEQ(name + 0,"MODE_", 5))
	    break;
	return constant_MODE_G(name, len, arg);
    case 'S':
	if (!strnEQ(name + 0,"MODE_", 5))
	    break;
	return constant_MODE_S(name, len, arg);
    case 'E':
	if (!strnEQ(name + 0,"SNMP_ERR_", 9))
	    break;
	return constant_SNMP_ERR(name, len, arg);
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

int
handler_wrapper(netsnmp_mib_handler          *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info   *reqinfo,
                netsnmp_request_info         *requests) 
{
    u_long intret = 5;
    handler_cb_data *cb_data = (handler_cb_data *) handler->myvoid;
    SV *cb;

    if (cb_data && (cb = cb_data->perl_cb)) {
        SV *arg;
        SV *rarg;
        dSP;
        ENTER;
        SAVETMPS;
        PUSHMARK(sp);
        rarg = newSViv(0);
        arg = newSVrv(rarg, "NetSNMP::agent::netsnmp_mib_handler");
        sv_setiv(arg, (IV) handler);
        XPUSHs(sv_2mortal(rarg));
        rarg = newSViv(0);
        arg = newSVrv(rarg, "NetSNMP::agent::reginfo");
        sv_setiv(arg, (IV) reginfo);
        XPUSHs(sv_2mortal(rarg));
        rarg = newSViv(0);
        arg = newSVrv(rarg, "NetSNMP::agent::netsnmp_agent_request_info");
        sv_setiv(arg, (IV) reqinfo);
        XPUSHs(sv_2mortal(rarg));
        rarg = newSViv(0);
        arg = newSVrv(rarg, "NetSNMP::agent::netsnmp_request_infoPtr");
        sv_setiv(arg, (IV) requests);
        XPUSHs(sv_2mortal(rarg));
        PUTBACK;
        if (SvTYPE(cb) == SVt_PVCV) {
            perl_call_sv(cb, G_DISCARD);
                                       
        } else if (SvROK(cb) && SvTYPE(SvRV(cb)) == SVt_PVCV) {
            perl_call_sv(SvRV(cb), G_DISCARD); 
        }
        SPAGAIN;
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
    return SNMP_ERR_NOERROR;
}

#line 436 "agent.c"

XS(XS_NetSNMP__agent_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent_constant)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::constant(sv, arg)");
    {
#line 431 "agent.xs"
	STRLEN		len;
#line 447 "agent.c"
	SV *	sv = ST(0);
	char *	s = SvPV(sv, len);
	int	arg = (int)SvIV(ST(1));
	double	RETVAL;
	dXSTARG;
#line 437 "agent.xs"
	RETVAL = constant(s,len,arg);
#line 455 "agent.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent___agent_check_and_process); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent___agent_check_and_process)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::__agent_check_and_process(block = 1)");
    {
	int	block;
	int	RETVAL;
	dXSTARG;

	if (items < 1)
	    block = 1;
	else {
	    block = (int)SvIV(ST(0));
	}
#line 445 "agent.xs"
	RETVAL = agent_check_and_process(block);
#line 480 "agent.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent_init_mib); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent_init_mib)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::init_mib()");
    {
#line 452 "agent.xs"
    {
        netsnmp_init_mib();
    }
#line 498 "agent.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent_init_agent); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent_init_agent)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::init_agent(name)");
    {
	const char *	name = (const char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;

	RETVAL = init_agent(name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent_init_snmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent_init_snmp)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::init_snmp(name)");
    {
	const char *	name = (const char *)SvPV_nolen(ST(0));

	init_snmp(name);
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent_init_master_agent); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent_init_master_agent)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::init_master_agent()");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = init_master_agent();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent_snmp_enable_stderrlog); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent_snmp_enable_stderrlog)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::snmp_enable_stderrlog()");
    {

	snmp_enable_stderrlog();
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent_shutdown); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent_shutdown)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::shutdown(me)");
    {
	SV *	me = ST(0);
#line 476 "agent.xs"
    {
        snmp_shutdown("perl");
    }
#line 580 "agent.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent_errlog); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent_errlog)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::errlog(me, value)");
    {
	SV *	me = ST(0);
	SV *	value = ST(1);
#line 485 "agent.xs"
        STRLEN stringlen;
        char * stringptr;
#line 598 "agent.c"
#line 488 "agent.xs"
    {
        stringptr = SvPV(value, stringlen);
        snmp_log(LOG_ERR, stringptr );
    }
#line 604 "agent.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent__netsnmp_handler_registration_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_handler_registration_new)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_handler_registration::new(name, regoid, perlcallback)");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
	char *	regoid = (char *)SvPV_nolen(ST(1));
	SV *	perlcallback = ST(2);
#line 503 "agent.xs"
	oid myoid[MAX_OID_LEN];
	size_t myoid_len = MAX_OID_LEN;
        handler_cb_data *cb_data;
        int gotit=1;
#line 625 "agent.c"
	netsnmp_handler_registration *	RETVAL;
#line 508 "agent.xs"
	if (!snmp_parse_oid(regoid, myoid, &myoid_len)) {
            if (!read_objid(regoid, myoid, &myoid_len)) {
                snmp_log(LOG_ERR, "couldn't parse %s (reg name: %s)\n",
                        regoid, name);
                RETVAL = NULL;
                gotit = 0;
            }
        }
        if (gotit) {
            cb_data = (handler_cb_data *) malloc(sizeof(handler_cb_data));
            RETVAL = netsnmp_create_handler_registration(name, handler_wrapper,
                                                 myoid, myoid_len,
                                                 HANDLER_CAN_RWRITE);
            cb_data->perl_cb = newSVsv(perlcallback);
            RETVAL->handler->myvoid = cb_data;
        }
#line 644 "agent.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "netsnmp_handler_registrationPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_netsnmp_handler_registrationPtr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_netsnmp_handler_registrationPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: netsnmp_handler_registrationPtr::DESTROY(reginfo)");
    {
	netsnmp_handler_registration *	reginfo;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    reginfo = INT2PTR(netsnmp_handler_registration *,tmp);
	}
	else
	    Perl_croak(aTHX_ "reginfo is not a reference");
#line 533 "agent.xs"
	netsnmp_handler_registration_free(reginfo);
#line 669 "agent.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_netsnmp_handler_registrationPtr_register); /* prototype to pass -Wmissing-prototypes */
XS(XS_netsnmp_handler_registrationPtr_register)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: netsnmp_handler_registrationPtr::register(me)");
    {
	SV *	me = ST(0);
#line 539 "agent.xs"
        netsnmp_handler_registration *reginfo;
#line 685 "agent.c"
	int	RETVAL;
	dXSTARG;
#line 541 "agent.xs"
            {
                reginfo = (netsnmp_handler_registration *) SvIV(SvRV(me));
                RETVAL = netsnmp_register_handler(reginfo);
                if (!RETVAL) {
                    /* the agent now has a "reference" to this reg pointer */
                    SvREFCNT_inc(me);
                }
            }
#line 697 "agent.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_netsnmp_handler_registrationPtr_getRootOID); /* prototype to pass -Wmissing-prototypes */
XS(XS_netsnmp_handler_registrationPtr_getRootOID)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: netsnmp_handler_registrationPtr::getRootOID(me)");
    SP -= items;
    {
	SV *	me = ST(0);
#line 556 "agent.xs"
        int i;
        netsnmp_oid *o;
        netsnmp_handler_registration *reginfo;
        SV *arg, *rarg;
#line 718 "agent.c"
#line 561 "agent.xs"
    {
        dSP;
        PUSHMARK(SP);
        reginfo = (netsnmp_handler_registration *) SvIV(SvRV(me));

        o = SNMP_MALLOC_TYPEDEF(netsnmp_oid);
        o->name = o->namebuf;
        o->len = reginfo->rootoid_len;
        memcpy(o->name, reginfo->rootoid,
               reginfo->rootoid_len * sizeof(oid));

        rarg = newSViv((int) 0);
        arg = newSVrv(rarg, "netsnmp_oidPtr");
        sv_setiv(arg, (IV) o);

        XPUSHs(sv_2mortal(rarg));

        PUTBACK;
        i = perl_call_pv("NetSNMP::OID::newwithptr", G_SCALAR);
        SPAGAIN;
        if (i != 1) {
            snmp_log(LOG_ERR, "unhandled OID error.\n");
            /* ack XXX */
        }
        ST(0) = POPs;
        XSRETURN(1);
    }
#line 747 "agent.c"
	PUTBACK;
	return;
    }
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getOID); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getOID)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::getOID(me)");
    SP -= items;
    {
	SV *	me = ST(0);
#line 595 "agent.xs"
        int i;
        netsnmp_oid *o;
        netsnmp_request_info *request;
        SV *arg, *rarg;
#line 768 "agent.c"
#line 600 "agent.xs"
    {
        dSP;
        PUSHMARK(SP);
        request = (netsnmp_request_info *) SvIV(SvRV(me));

        o = SNMP_MALLOC_TYPEDEF(netsnmp_oid);
        o->name = o->namebuf;
        o->len = request->requestvb->name_length;
        memcpy(o->name, request->requestvb->name,
               request->requestvb->name_length * sizeof(oid));

        rarg = newSViv((int) 0);
        arg = newSVrv(rarg, "netsnmp_oidPtr");
        sv_setiv(arg, (IV) o);

        XPUSHs(sv_2mortal(rarg));

        PUTBACK;
        i = perl_call_pv("NetSNMP::OID::newwithptr", G_SCALAR);
        SPAGAIN;
        if (i != 1) {
            snmp_log(LOG_ERR, "unhandled OID error.\n");
            /* ack XXX */
        }
        ST(0) = POPs;
        XSRETURN(1);
    }
#line 797 "agent.c"
	PUTBACK;
	return;
    }
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getOIDptr); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getOIDptr)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::getOIDptr(me)");
    {
	SV *	me = ST(0);
#line 632 "agent.xs"
        netsnmp_request_info *request;
#line 814 "agent.c"
	netsnmp_oid *	RETVAL;
#line 634 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        RETVAL = SNMP_MALLOC_TYPEDEF(netsnmp_oid);
        RETVAL->name = RETVAL->namebuf;
        RETVAL->len = request->requestvb->name_length;
        memcpy(RETVAL->name, request->requestvb->name,
               request->requestvb->name_length * sizeof(oid));
#line 823 "agent.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "netsnmp_oidPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getType); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getType)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::getType(me)");
    {
	SV *	me = ST(0);
#line 647 "agent.xs"
        netsnmp_request_info *request;
#line 841 "agent.c"
	int	RETVAL;
	dXSTARG;
#line 649 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));

        RETVAL =  request->requestvb->type ;
#line 848 "agent.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setType); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setType)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::setType(me, newvalue)");
    {
	SV *	me = ST(0);
	int	newvalue = (int)SvIV(ST(1));
#line 660 "agent.xs"
        netsnmp_request_info *request;
#line 866 "agent.c"
#line 662 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        request->requestvb->type=newvalue;
#line 870 "agent.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getValue)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::getValue(me)");
    {
	SV *	me = ST(0);
#line 669 "agent.xs"
        u_char buf[1024] ;
        u_char *oidbuf = buf ;
        size_t ob_len = 1024, oo_len = 0;
        netsnmp_request_info *request;
#line 889 "agent.c"
	char *	RETVAL;
	dXSTARG;
#line 674 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
	sprint_realloc_by_type(&oidbuf, &ob_len, &oo_len, 0,
                               request->requestvb, 0, 0, 0);
        RETVAL = oidbuf; /* mem leak */
#line 897 "agent.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getDelegated); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getDelegated)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::getDelegated(me)");
    {
	SV *	me = ST(0);
#line 685 "agent.xs"
        netsnmp_request_info *request;
#line 914 "agent.c"
	int	RETVAL;
	dXSTARG;
#line 687 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        RETVAL = request->delegated;
#line 920 "agent.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setDelegated); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setDelegated)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::setDelegated(me, newdelegated)");
    {
	SV *	me = ST(0);
	int	newdelegated = (int)SvIV(ST(1));
#line 697 "agent.xs"
        netsnmp_request_info *request;
#line 938 "agent.c"
#line 699 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        request->delegated = newdelegated;
#line 942 "agent.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getProcessed); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getProcessed)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::getProcessed(me)");
    {
	SV *	me = ST(0);
#line 706 "agent.xs"
        netsnmp_request_info *request;
#line 958 "agent.c"
	int	RETVAL;
	dXSTARG;
#line 708 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        RETVAL = request->processed;
#line 964 "agent.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setProcessed); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setProcessed)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::setProcessed(me, newprocessed)");
    {
	SV *	me = ST(0);
	int	newprocessed = (int)SvIV(ST(1));
#line 718 "agent.xs"
        netsnmp_request_info *request;
#line 982 "agent.c"
#line 720 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        request->processed = newprocessed;
#line 986 "agent.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getStatus); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getStatus)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::getStatus(me)");
    {
	SV *	me = ST(0);
#line 727 "agent.xs"
        netsnmp_request_info *request;
#line 1002 "agent.c"
	int	RETVAL;
	dXSTARG;
#line 729 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        RETVAL = request->status;
#line 1008 "agent.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setStatus); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setStatus)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::setStatus(me, newstatus)");
    {
	SV *	me = ST(0);
	int	newstatus = (int)SvIV(ST(1));
#line 739 "agent.xs"
        netsnmp_request_info *request;
#line 1026 "agent.c"
#line 741 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        request->status = newstatus;
#line 1030 "agent.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getRepeat); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_getRepeat)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::getRepeat(me)");
    {
	SV *	me = ST(0);
#line 748 "agent.xs"
        netsnmp_request_info *request;
#line 1046 "agent.c"
	int	RETVAL;
	dXSTARG;
#line 750 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        RETVAL = request->repeat;
#line 1052 "agent.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setRepeat); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setRepeat)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::setRepeat(me, newrepeat)");
    {
	SV *	me = ST(0);
	int	newrepeat = (int)SvIV(ST(1));
#line 760 "agent.xs"
        netsnmp_request_info *request;
#line 1070 "agent.c"
#line 762 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        request->repeat = newrepeat;
#line 1074 "agent.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setValue)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::setValue(me, type, value)");
    {
	SV *	me = ST(0);
	int	type = (int)SvIV(ST(1));
	SV *	value = ST(2);
#line 771 "agent.xs"
        u_char *oidbuf = NULL;
        size_t ob_len = 0, oo_len = 0;
        netsnmp_request_info *request;
        u_long utmp;
        long ltmp;
	oid myoid[MAX_OID_LEN];
	size_t myoid_len;
        STRLEN stringlen;
        char * stringptr;
#line 1100 "agent.c"
	int	RETVAL;
	dXSTARG;
#line 781 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        switch(type) {
          case  SNMP_NOSUCHINSTANCE :
              snmp_set_var_typed_value(request->requestvb,SNMP_NOSUCHINSTANCE,0,0) ;
              RETVAL = 1;
              break ;
          case  SNMP_NOSUCHOBJECT :
              snmp_set_var_typed_value(request->requestvb,SNMP_NOSUCHOBJECT,0,0) ;
              RETVAL = 1;
              break ;
          case  SNMP_ENDOFMIBVIEW :
              snmp_set_var_typed_value(request->requestvb,SNMP_ENDOFMIBVIEW,0,0) ;
              RETVAL = 1;
              break ;
          case ASN_INTEGER:
	      /* We want an integer here */
	      if ((SvTYPE(value) == SVt_IV) || (SvTYPE(value) == SVt_PVMG)) {
		  /* Good - got a real one (or a blessed object that we hope will turn out OK) */
		  ltmp = SvIV(value);
		  snmp_set_var_typed_value(request->requestvb, (u_char)type,
					   (u_char *) &ltmp, sizeof(ltmp));
		  RETVAL = 1;
		  break;
	      }
	      else if (SvPOKp(value)) {
	          /* Might be OK - got a string, so try to convert it, allowing base 10, octal, and hex forms */
	          stringptr = SvPV(value, stringlen);
		  ltmp = strtol( stringptr, NULL, 0 );
		  if (errno == EINVAL) {
		  	snmp_log(LOG_ERR, "Could not convert string to number in setValue: '%s'", stringptr);
			RETVAL = 0;
			break;
		  }

		  snmp_set_var_typed_value(request->requestvb, (u_char)type,
					   (u_char *) &ltmp, sizeof(ltmp));
		  RETVAL = 1;
		  break;
	      }
	      else {
		snmp_log(LOG_ERR, "Non-integer value passed to setValue with ASN_INTEGER: type was %d\n",
			SvTYPE(value));
		RETVAL = 0;
		break;
	      }


          case ASN_UNSIGNED:
          case ASN_COUNTER:
          case ASN_COUNTER64:
          case ASN_TIMETICKS:
	      /* We want an integer here */
	      if ((SvTYPE(value) == SVt_IV) || (SvTYPE(value) == SVt_PVMG)) {
		  /* Good - got a real one (or a blessed scalar which we have to hope will turn out OK) */
		  utmp = SvIV(value);
                  snmp_set_var_typed_value(request->requestvb, (u_char)type,
                                       (u_char *) &utmp, sizeof(utmp));
		  RETVAL = 1;
		  break;
	      }
	      else if (SvPOKp(value)) {
	          /* Might be OK - got a string, so try to convert it, allowing base 10, octal, and hex forms */
	          stringptr = SvPV(value, stringlen);
		  utmp = strtoul( stringptr, NULL, 0 );
		  if (errno == EINVAL) {
		  	snmp_log(LOG_ERR, "Could not convert string to number in setValue: '%s'", stringptr);
			RETVAL = 0;
			break;
		  }

                  snmp_set_var_typed_value(request->requestvb, (u_char)type,
                                       (u_char *) &utmp, sizeof(utmp));
		  RETVAL = 1;
		  break;
	      }
	      else {
		snmp_log(LOG_ERR, "Non-unsigned-integer value passed to setValue with ASN_UNSIGNED/ASN_COUNTER/ASN_TIMETICKS: type was %d\n",
			SvTYPE(value));
		RETVAL = 0;
		break;
	      }

          case ASN_OCTET_STR:
          case ASN_BIT_STR:
	      /* Check that we have been passed something with a string value (or a blessed scalar) */
	      if (!SvPOKp(value) && (SvTYPE(value) != SVt_PVMG)) {
		snmp_log(LOG_ERR, "Non-string value passed to setValue with ASN_OCTET_STR/ASN_BIT_STR: type was %d\n",
			SvTYPE(value));
		RETVAL = 0;
		break;
	      }

	      /* Find length of string (strlen will *not* do, as these are binary strings) */
	      stringptr = SvPV(value, stringlen);

              snmp_set_var_typed_value(request->requestvb, (u_char)type,
                                       (u_char *) stringptr,
                                       stringlen);
              RETVAL = 1;
              break;

          case ASN_IPADDRESS:
	      /* IP addresses are passed as *binary* strings.
	       * In the case of IPv4 addresses, these are 4 bytes long.
	       * NOTE: the use of binary strings rather than dotted-quad or FQDNs was
	       * introduced here by Andrew Findlay's patch of March 17th 2003,
	       * and is effectively a change to the previous implied API which assumed
	       * the value was a (valid) hostname.
	       * Responsibility for decoding and resolving has been passed up to the Perl script.
	       */

	      /* Check that we have been passed something with a string value (or a blessed scalar) */
	      if (!SvPOKp(value) && (SvTYPE(value) != SVt_PVMG)) {
		snmp_log(LOG_ERR, "Non-string value passed to setValue with ASN_IPADDRESS: type was %d\n",
			SvTYPE(value));
		RETVAL = 0;
		break;
	      }

	      /* Find length of string (strlen will *not* do, as these are binary strings) */
	      stringptr = SvPV(value, stringlen);


	      if ((stringlen != 4) && (stringlen != 16)) {
	      		snmp_log(LOG_ERR, "IP address of %d bytes passed to setValue with ASN_IPADDRESS\n", stringlen);
			RETVAL = 0;
			break;
	      }

              snmp_set_var_typed_value(request->requestvb, (u_char)type,
                                   stringptr, stringlen);
              RETVAL = 1;
              break;

          case ASN_OBJECT_ID:
	      /* Check that we have been passed something with a string value (or a blessed scalar) */
	      if (!SvPOKp(value) && (SvTYPE(value) != SVt_PVMG)) {
		snmp_log(LOG_ERR, "Non-string value passed to setValue with ASN_OBJECT_ID: type was %d\n",
			SvTYPE(value));
		RETVAL = 0;
		break;
	      }

	      /* Extract the string */
	      stringptr = SvPV(value, stringlen);

	      /* snmp_log(LOG_ERR, "setValue returning OID '%s'\n", stringptr); */

	      myoid_len = MAX_OID_LEN;
              if (!snmp_parse_oid(stringptr, myoid, &myoid_len)) {
                  snmp_log(LOG_ERR, "couldn't parse %s in setValue\n", stringptr);
		  RETVAL = 0;
		  break;
              } else {
		  /* snmp_log(LOG_ERR, "setValue returning OID length %d\n", myoid_len); */

                  request = (netsnmp_request_info *) SvIV(SvRV(me));
                  snmp_set_var_typed_value(request->requestvb, (u_char)type,
                                           (u_char *) myoid, (myoid_len * sizeof(myoid[0])) );
              }

              RETVAL = 1;
              break;

            default:
                snmp_log(LOG_ERR, "unknown var value type: %d\n",
                        type);
                RETVAL = 0;
                break;
        }

#line 1275 "agent.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setOID); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setOID)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::setOID(me, value)");
    {
	SV *	me = ST(0);
	char *	value = (char *)SvPV_nolen(ST(1));
#line 963 "agent.xs"
	oid myoid[MAX_OID_LEN];
	size_t myoid_len = MAX_OID_LEN;
        netsnmp_request_info *request;
#line 1295 "agent.c"
#line 967 "agent.xs"
	myoid_len = MAX_OID_LEN;
	if (!snmp_parse_oid(value, myoid, &myoid_len)) {
            snmp_log(LOG_ERR, "couldn't parse %s in setOID\n", value);
        } else {
            request = (netsnmp_request_info *) SvIV(SvRV(me));
            snmp_set_var_objid(request->requestvb, myoid, myoid_len);
        }
#line 1304 "agent.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setError); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_setError)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::setError(me, rinfo, ecode)");
    {
	SV *	me = ST(0);
	SV *	rinfo = ST(1);
	int	ecode = (int)SvIV(ST(2));
#line 981 "agent.xs"
	oid myoid[MAX_OID_LEN];
	size_t myoid_len = MAX_OID_LEN;
        netsnmp_request_info *request;
        netsnmp_agent_request_info *reqinfo;
#line 1325 "agent.c"
#line 986 "agent.xs"
        request = (netsnmp_request_info *) SvIV(SvRV(me));
        reqinfo = (netsnmp_agent_request_info *) SvIV(SvRV(rinfo));
        netsnmp_set_request_error(reqinfo, request, ecode);
#line 1330 "agent.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_request_infoPtr_next)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_request_infoPtr::next(me)");
    {
	SV *	me = ST(0);
#line 994 "agent.xs"
        netsnmp_request_info *request;
        SV *arg, *rarg;
#line 1347 "agent.c"
	SV *	RETVAL;
#line 997 "agent.xs"
        {
            request = (netsnmp_request_info *) SvIV(SvRV(me));
            if (request && request->next) {
                request = request->next;
                rarg = newSViv(0);
                arg = newSVrv(rarg, "NetSNMP::agent::netsnmp_request_infoPtr");
                sv_setiv(arg, (IV) request);
                RETVAL = rarg;				
            } else {
                RETVAL = &sv_undef;
            }
        }
#line 1362 "agent.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent__netsnmp_agent_request_info_getMode); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_agent_request_info_getMode)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_agent_request_info::getMode(me)");
    {
	SV *	me = ST(0);
#line 1018 "agent.xs"
        netsnmp_agent_request_info *reqinfo;
#line 1380 "agent.c"
	int	RETVAL;
	dXSTARG;
#line 1020 "agent.xs"
        reqinfo = (netsnmp_agent_request_info *) SvIV(SvRV(me));
        RETVAL = reqinfo->mode;
#line 1386 "agent.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_NetSNMP__agent__netsnmp_agent_request_info_setMode); /* prototype to pass -Wmissing-prototypes */
XS(XS_NetSNMP__agent__netsnmp_agent_request_info_setMode)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: NetSNMP::agent::netsnmp_agent_request_info::setMode(me, newvalue)");
    {
	SV *	me = ST(0);
	int	newvalue = (int)SvIV(ST(1));
#line 1030 "agent.xs"
        netsnmp_agent_request_info *reqinfo;
#line 1404 "agent.c"
#line 1032 "agent.xs"
        reqinfo = (netsnmp_agent_request_info *) SvIV(SvRV(me));
        reqinfo->mode = newvalue;
#line 1408 "agent.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_NetSNMP__agent); /* prototype to pass -Wmissing-prototypes */
XS(boot_NetSNMP__agent)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXSproto("NetSNMP::agent::constant", XS_NetSNMP__agent_constant, file, "$$");
        newXSproto("NetSNMP::agent::__agent_check_and_process", XS_NetSNMP__agent___agent_check_and_process, file, ";$");
        newXSproto("NetSNMP::agent::init_mib", XS_NetSNMP__agent_init_mib, file, "");
        newXSproto("NetSNMP::agent::init_agent", XS_NetSNMP__agent_init_agent, file, "$");
        newXSproto("NetSNMP::agent::init_snmp", XS_NetSNMP__agent_init_snmp, file, "$");
        newXSproto("NetSNMP::agent::init_master_agent", XS_NetSNMP__agent_init_master_agent, file, "");
        newXSproto("NetSNMP::agent::snmp_enable_stderrlog", XS_NetSNMP__agent_snmp_enable_stderrlog, file, "");
        newXSproto("NetSNMP::agent::shutdown", XS_NetSNMP__agent_shutdown, file, "$");
        newXSproto("NetSNMP::agent::errlog", XS_NetSNMP__agent_errlog, file, "$$");
        newXSproto("NetSNMP::agent::netsnmp_handler_registration::new", XS_NetSNMP__agent__netsnmp_handler_registration_new, file, "$$$");
        newXSproto("netsnmp_handler_registrationPtr::DESTROY", XS_netsnmp_handler_registrationPtr_DESTROY, file, "$");
        newXSproto("netsnmp_handler_registrationPtr::register", XS_netsnmp_handler_registrationPtr_register, file, "$");
        newXSproto("netsnmp_handler_registrationPtr::getRootOID", XS_netsnmp_handler_registrationPtr_getRootOID, file, "$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::getOID", XS_NetSNMP__agent__netsnmp_request_infoPtr_getOID, file, "$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::getOIDptr", XS_NetSNMP__agent__netsnmp_request_infoPtr_getOIDptr, file, "$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::getType", XS_NetSNMP__agent__netsnmp_request_infoPtr_getType, file, "$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::setType", XS_NetSNMP__agent__netsnmp_request_infoPtr_setType, file, "$$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::getValue", XS_NetSNMP__agent__netsnmp_request_infoPtr_getValue, file, "$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::getDelegated", XS_NetSNMP__agent__netsnmp_request_infoPtr_getDelegated, file, "$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::setDelegated", XS_NetSNMP__agent__netsnmp_request_infoPtr_setDelegated, file, "$$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::getProcessed", XS_NetSNMP__agent__netsnmp_request_infoPtr_getProcessed, file, "$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::setProcessed", XS_NetSNMP__agent__netsnmp_request_infoPtr_setProcessed, file, "$$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::getStatus", XS_NetSNMP__agent__netsnmp_request_infoPtr_getStatus, file, "$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::setStatus", XS_NetSNMP__agent__netsnmp_request_infoPtr_setStatus, file, "$$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::getRepeat", XS_NetSNMP__agent__netsnmp_request_infoPtr_getRepeat, file, "$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::setRepeat", XS_NetSNMP__agent__netsnmp_request_infoPtr_setRepeat, file, "$$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::setValue", XS_NetSNMP__agent__netsnmp_request_infoPtr_setValue, file, "$$$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::setOID", XS_NetSNMP__agent__netsnmp_request_infoPtr_setOID, file, "$$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::setError", XS_NetSNMP__agent__netsnmp_request_infoPtr_setError, file, "$$$");
        newXSproto("NetSNMP::agent::netsnmp_request_infoPtr::next", XS_NetSNMP__agent__netsnmp_request_infoPtr_next, file, "$");
        newXSproto("NetSNMP::agent::netsnmp_agent_request_info::getMode", XS_NetSNMP__agent__netsnmp_agent_request_info_getMode, file, "$");
        newXSproto("NetSNMP::agent::netsnmp_agent_request_info::setMode", XS_NetSNMP__agent__netsnmp_agent_request_info_setMode, file, "$$");
    XSRETURN_YES;
}

